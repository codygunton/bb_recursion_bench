{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":8395964289138718954,"abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":114,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":93,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"private"},{"name":"key_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/4XWVVNVARiF4Y1iYncidncXYnd3IXYXdiF2dxdid3djt+IfcuSdvR3fO/fMmfNw9hUX31orJgif7JxPTGS+43I+qfqb53fkGDmXnFuOlfPIeeV8cn65gFxQjpMLyYXlInJRuZhcXC4hl5RLyaXlMnJZuZxcXq4gV5QryZXleLmKnCBXlavJ1eUack25llxbriPXlevJ9eUGckO5kdxYbiI3lZvJzeUWcku5ldxabiO3ldvJ7eUOckc5Ue4kJ8md5S5yV7mb3F3uIfeUe8m95T5yX7mf3F8eIA+UB8mD5SHyUHmYPFweIY+UR8mj5THyWHmcPF5OlifIKfJEeZI8WZ4iT5WnydPlGfJMeZY8W54jz5XnyfPlBfLCyPzfQfRbqt4vkhfLS+Sl8jJ5ubxCXimvklfLa+Q0ea2cLq+T18sb5I3yJnmzvEXeKm+Tt8s75J3yLnm3vEfeK++T98sH5IPyIfmwfEQ+Kh+Tj8sn5JPyKTlDPi1nymfks/I5+bx8Qb4oX5Ivy1fkq/I1+bp8Q74p35Jvy3fku/I9+b78QH4oP5Ify0/kp/Iz+bn8Qn4pv5Kz5NfyG/mt/E5+L3+QP8qf5M/yF/mr/E3+Lv+Qg+j7p37Ljvz3XWzkX8G/h9/Zd7mj9+w49hu7jb3GTmOfscvYY+ww9he7i73FzmJfsavYU+wo9hO7ib3ETmIfsYvYQ+yg+CDcPQlBuHPYN+wa9gw7hv3CbmGvsFPYJ+wS9gg7hP3B7mBvsDPYF+wK9gQ7gv3AbmAvsBPYB+wC9gA7IDEIez8pCHuefqfX6XN6nP6mt+lrepp+ppfpY3qY/qV36Vt6ln6lV+lTepT+pDfpS3qSfqQX6UP6IDkIey8lCHuOfqPX6DN6jP6it+greop+opfoI3qI/qF36Bt6hl6hT+gR+oPeoC/oCfqBXqAP6AHyPy0I8z49CPOdXCfPyXHym9wmr8lp8plcJo/JYfKX3CVvyVnylVwlT8lR8pPcJC/JSfKRXCQPyUHyLyMI8y4zCPONXCPPyDHyi9wir8gp8olcIo/IIfKH3CFvyBnyhVwhT8gR8oPcIC/ICfKBXCAPyAHun7vn3rOC8L65a+6ZO+Z+uVvulTvlPrlL7pE75P64O+6M+/rf8welslAqfA0AAA==","debug_symbols":"ZY1LCsMgFEX38sYZJFELdSulBL9BEBU/hSLuvSYkJZDhufe8+ypIxcu6GKd9AvqqYL1g2XjXqcK4Rykwt1HKLGagM0EDKCeBIoLbANpYBfQxt+GmTgiTw53w9PzLaGzvDjwaa826XH/2+MOiYdyqA3Vx4tLmbzib8z5EL5QsUW1Le9fnfw==","file_map":{"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"62":{"source":"use std::hash::poseidon;\nuse std::verify_proof;\n\nfn main(\n    verification_key: [Field; 114],\n    proof: [Field; 93],\n    public_inputs: [Field; 1],\n    key_hash: Field,\n) {\n    for _ in 0..250 {\n        let _ = poseidon::bn254::hash_1([1]);\n    }\n\n    verify_proof(\n        verification_key,\n        proof,\n        public_inputs,\n        key_hash,\n    );\n}\n","path":"/Users/cody/bb_recursion_bench/recursion/src/main.nr"}},"names":["main"],"brillig_names":[]}